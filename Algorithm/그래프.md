





###  상호배타집합

```python
Make_Set(x)
	p[x] <- x
    
Find_Set(x)
	if x == p[x] : return x
    else : return
Find_Set(x)
```







## 최소 비용 신장 트리 MST

> 최소 신장 트리 MST

- 그래프에서 최소 비용 문제
  - 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
  - 두 정점 사이의 최소 비용의 경로 찾기
- 신장 트리
  - n개의 정점으로 이루어진 무방향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리
- 최소 신장 트리(Minimum Spanning Tree)
  - 무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소 신장 트리



#### ❤️Prim 알고리즘

- 하나의 정점에서 연결된 간선들 중에서 하나씩 선택하면서 MST를 만들어가는 방식
  - 임의 정점을 하나 선택해서 시작
  - 선택한 정점과 인접하는 정점들 중의 최소 비용의 간선이 존재하는 정점을 선택
  - 모든 정점이 선택될 때까지 1), 2) 과정을 반복
- 서로소인 2개의 집합(2 disjoint-sets) 정보를 유지
  - 트리 정점들(tree vertices) - MST를 만들기 위해 선택된 정점들
  - 비트리 정점들(nontree vertives) - 선택되지 않은 정점들

```python
MST_PRIM(G,r)   # 그래프 / 시작정점
	for u in G,v
    	u.key <- infinite  # u.key = u에 연결된 간선중 최소 가중치
        u.π <- NULL      # u.π = 트리에서 u의 부모
        
    r.key <- 0
    Q <- G.V				# 우선순위 Q에 모든 정점 넣는다
    while Q != 0			# 빈 Q가 아닐동안 반복 = MST에 속하지 않은 정점이 있으면
    	u <- Extract_Min(Q) # key 값이 가장 작은 정점 가져오기
        for v in G.adj[u]   # u의 인접 정점들
        	if v ∈ Q and w(u,v) < v.key  # Q에 있는 v의 key 값 갱신
            	v.π <- u
                v.key <- w(u,v)
```

```python
def prim1(r,v):
    MST = [0] * (v+1)  # MST 포함여부
    key = [10000] * (v+1)  # 가중치의 최대값 이상으로 초기화. key[v]는 v가 MST에 속한 정점과 연결될 때의 가중치
    key[r] = 0 # 시작정점의 key
    for _ in range(v): # v+1개의 정점 중에서 v개를 선택
        # MST에 포함되지 않은 정점 중 (MST[u] == 0), key가 최소인 u 찾기
        u = 0
        minV = 10000
        for i in range(v+1):
            if MST[i] == 0 and key[i] < minV:
                u = i
                minV = key[i]
        MST[u] = 1  # 정점 u를 MST에 추가
        
        for v in range(v+1):
            if MST[v] == 0 and adjM[u][v] > 0:
                # u를 통해 MST에 포함되는 비용과 기존 비용을 비교, 갱신
                key[v] = min(key[v],adjM[u][v])  
    return sum(key)   # MST 가중치의 합
```

```python
def prim2(r,v):
    MST = [0] * (v+1)   # MST 포함 여부
    MST[r] = 1
    s = 0  # 최소 가중치의 합
    for _ in range(v):
        u = 0
        minV = 10000
        for i in range(v+1):
            if MST[i] == 1:
                for j in range(v+1):
                    if o<adjM[i][j] < minV and MST[j] == 0:
                        u = j
                        minV = adjM[i][j]
        s += minV
        MST[u] = 1
   return s
```



----



#### 💙 KRUSKAL 알고리즘

- 간선을 하나씩 선택해서 MST를 찾는 알고리즘
  - 최초, 모든 간선을 가중치에 따라 오름차순으로 정렬
  - 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
    - 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택
  - n-1 개의 간선이 선택될 때까지 2)를 반복







### 최단경로

- 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로
- 하나의 시작 정점에서 끝 정점까지의 최단경로
  - 다익스트라(dijkstra) 알고리즘
    - 음의 가중치를 허용하지 않음
  - 벨만-포드(Bellman_Ford) 알고리즘
    - 음의 가중치 허용
- 모든 정점들에 대한 최단 경로
  - 플로이드-워샬(Floyd-Warchall) 알고리즘



> Dijkstra 알고리즘

- 시작 정점에서 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식
- 시작정점(s)에서 끝정점(t)까지의 최단 경로에 정점 x가 존재한다
- 이때, 최단경로는 s에서 x까지의 최단 경로와 x에서 t까지의 최단 경로로 구성된다.



```python
Dijkstra(s,a,d)
	u = {s};
    
    for 모든 정점 v
    	d[v] <- a[s][v]
        
    while u != v
    	d[w]가 최소인 정점 w ∈ v-u를 선택
        u <- u ∪ {w}
        
        for w에 인접한 모든 정점 v
        	d[v] <- min(d[v], d[w] + a[w][v])
```

