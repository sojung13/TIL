### 11. 배열 렌더링하기

```react
import React from 'react';

function User({ user }) {
  return (
    <div>
      <b>{user.username}</b> <span>({user.email})</span>
    </div>
  );
}

// 한 파일 안에 여러 개의 컴포넌트를 선언해도 괜찮다!!
function UserList() {
  const users = [
    {
      id: 1,
      username: 'velopert',
      email: 'public.velopert@gmail.com'
    },
    {
      id: 2,
      username: 'tester',
      email: 'tester@example.com'
    },
    {
      id: 3,
      username: 'liz',
      email: 'liz@example.com'
    }
  ];

  return (
    <div>
      {users.map(user => (
        // 리액트에서 배열을 렌더링할 때는 key라는 props를 설정해야 한다.
        // key 값은 각 원소들마다 가지고 있는 고유값으로 설정해야 한다!!
        // 지금의 경우는 id가 고유값이지만, id가 없는 경우 아래 설명 참조
        <User user={user} key={user.id} />
      ))}
    </div>
  );
}

export default UserList;
```

- `map`은 배열 안의 각 원소를 변환할 때 사용되며, 이 과정에서 새로운 배열이 만들어진다.



- 👉 id값이 없어 key 값을 설정 못할 때는 콜백 함수의 두번째 파라미터인 index를 key로 설정하면 된다.

```react
<div>
  {users.map((user, index) => (
    <User user={user} key={index} />
  ))}
</div>
```

- key 값을 설정해주지 않으면, 수정되지 않은 기존의 값은 그대로 두고 원하는 곳에 내용을 삽입하거나 삭제가 가능하다. 즉, 비효율적인 수정을 피할 수 있다!!



----



### 12. useRef로 컴포넌트 안의 변수 만들기

- `useRef` HOOK은 DOM을 선택하는 용도 외에도, 컴포넌트 안에서 조회 및 수정할 수 있는 변수를 관리할 수 있게 해준다.
- `useRef`로 관리하는 변수는 값이 바뀐다고 해서 컴포넌트가 리렌더링되지는 않는다.
- 리액트 컴포넌트에서의 상태는 상태를 바꾸는 함수를 호출하고 나서 그 다음 렌더링 이후로 업데이트된 상태ㄹ를 조회할 수 있는 반면, `useRef`로 관리하고 있는 변수는 설정 후 바로 조회할 수 있다.
  - `setTimeout`, `setInterval`을 통해서 만들어진 `id`
  - 외부 라이브러리를 사용하여 생성된 인스턴스
  - scroll 위치

```react
// App.js
import React, { useRef } from 'react';
import UserList from './UserList';

function App() {
  const users = [
    {
      id: 1,
      username: 'velopert',
      email: 'public.velopert@gmail.com'
    },
    {
      id: 2,
      username: 'tester',
      email: 'tester@example.com'
    },
    {
      id: 3,
      username: 'liz',
      email: 'liz@example.com'
    }
  ];

  const nextId = useRef(4);
  const onCreate = () => {
    // 나중에 구현 할 배열에 항목 추가하는 로직
    // ...

    nextId.current += 1;
  };
  return <UserList users={users} />;
}

export default App;
```

```react
// UserList.js
import React from 'react';

function User({ user }) {
  return (
    <div>
      <b>{user.username}</b> <span>({user.email})</span>
    </div>
  );
}

function UserList({ users }) {
  return (
    <div>
      {users.map(user => (
        <User user={user} key={user.id} />
      ))}
    </div>
  );
}

export default UserList;
```

- `useRef`를 사용하는 이유는 리렌더링 없이 변수값의 변화를 이용하기 위함이다!



-----



### 13. 배열에 항목 추가하기

```react
import React, { useRef, useState } from 'react';
import UserList from './UserList';
import CreateUser from './CreateUser';

function App() {
  const [inputs, setInputs] = useState({
    username: '',
    email: ''
  });
  const { username, email } = inputs;
  const onChange = e => {
    const { name, value } = e.target;
    setInputs({
      ...inputs,
      [name]: value
    });
  };
  const [users, setUsers] = useState([
    {
      id: 1,
      username: 'velopert',
      email: 'public.velopert@gmail.com'
    },
    {
      id: 2,
      username: 'tester',
      email: 'tester@example.com'
    },
    {
      id: 3,
      username: 'liz',
      email: 'liz@example.com'
    }
  ]);

  const nextId = useRef(4);
  const onCreate = () => {
    const user = {
      id: nextId.current,
      username,
      email
    };
    setUsers([...users, user]);
   	// concat 함수를 사용하여 작성하는 방법도 있다!!
    // concat 함수는 기존의 배열을 수정하지 않고, 새로운 원소가 추가된 새로운 배열을 만들어준다.
   	// setUsers(users.concat(user));
      

    setInputs({
      username: '',
      email: ''
    });
    nextId.current += 1;
  };
  return (
    <>
      <CreateUser
        username={username}
        email={email}
        onChange={onChange}
        onCreate={onCreate}
      />
      <UserList users={users} />
    </>
  );
}

export default App;
```

![image-20220615010736165](벨로퍼트2.assets/image-20220615010736165.png)

