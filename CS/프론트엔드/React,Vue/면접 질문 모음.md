**Q. 컴포넌트가 무엇인지 설명해보세요.**

컴포넌트는 프로그래밍에 있어 재사용이 가능한 각각의 독립된 모듈을 의미합니다. 리액트 관점에선 함수형 컴포넌트와 클래스형 컴포넌트 활용이 가능해 컴포넌트 별 특징을 살려 코드 작성이 가능합니다.

이러한 웹 컴포넌트를 활용하는 이유는 관심사별로 컴포넌트를 관리하고, 다른 컴포넌트와 스타일 충돌을 피하기 위해 사용합니다.



**Q. Vue와 React 차이점이 무엇인지 설명해보세요.**

먼저 React는 JavaScript 라이브러리라 전역 상태 관리 등을 지원하지 않아 별도의 라이브러리를 활용해야 합니다. 반면 Vue는 프레임워크이기 때문에 내장 기능이 디폴트로 지원됩니다.

React는 JavaScript 문법을 응용하기 때문에 JavaScript 언어만으로 UI 로직과 DOM을 구현할 수 있지만 Vue는 HTML, CSS, JS 코드를 분리하여 작성합니다. 때문에 React는 파일별로 컴포넌트 분리가 가능하고 다른 곳에서 재사용이 매우 용이하다는 장점이 있지만 Vue는 새로운 컴포넌트를 만들기 위해서 모든 template, script, style을 모두 작성해주어야 합니다. 

마지막으로 데이터 바인딩 방향의 차이점이 있는데, 먼저 데이터 바인딩은 화면에 보이는 데이터와 브라우저 메모리에 있는 데이터를 일치시키는 방법입니다. 단방향 데이터 바인딩은 데이터가 부모에서 자식 컴포넌트로 흐르는 단방향으로, 추적과 디버깅이 쉽다는 장점이 있습니다. 양방향 데이터 바인딩은 데이터가 부모와 자식 양방향으로 흐르며, 사용자가 입력하는대로 화면에 반영된다는 장점이 있지만 데이터 변화에 따라 DOM 객체 전체를 렌더링해줘야 하기 때문에 성능 저하의 우려가 있습니다. React는 단방향 데이터 흐름을 사용하고 Vue는 단방향, 양방향 데이터 모두를 사용합니다.



**Q. Virtual DOM이 무엇인지 설명해보세요.**

DOM이란 웹 페이지의 HTML 요소들을 구조적으로 표현한 것으로, 트리 데이터 구조로 표현됩니다. 이런 DOM은 노드의 수가 많아질수록 속도가 느려지고 DOM 트리가 수정될 때마다 렌더 트리가 실시간으로 갱신되기 때문에 성능에 영향을 미치게 됩니다. 

Virtual DOM은 UI의 가상적인 표현을 메모리에 저장하고 ReactDOM과 같은 라이브러리에 의해 실제 DOM과 동기화하는 프로그래밍 개념입니다. DOM을 가볍게 만든 JavaScript 개념으로 모든 변화를 묶어서 한 번만에 변화를 반영해준다는 장점이 있습니다. 



React의 Diffing Algorithm은 이전 트리와의 차이점을 구하는 작업으로, 컴포넌트가 어떻게 바뀌었는지 찾아내는 것입니다.



**Q. props와 state가 무엇인지 설명해보세요.**

props는 부모 컴포넌트에서 자식 컴포넌트로 상속하는 객체를 의미합니다. 수정을 위해서는 부모 컴포넌트에서 수정을 거쳐야 합니다. 반면 state는 현재 컴포넌트에서 생성, 업데이트가 가능한 데이터를 의미합니다. state는 각각의 컴포넌트 내부에서 독립적으로 생성되어 사용되는 요소이기 때문에 다른 컴포넌트 간의 접근을 고려하지 않아도 됩니다. 대신 props는 특성 자체가 부모에서 자식 컴포넌트로 상속하여 발생하는 개념이라 state와는 생성되고 사용되는 위치에 따른 차이점이 생깁니다.



**Q. 하위 컴포넌트 수정은 어떻게 하는지 설명해보세요.**

Vue에서 emit을 사용해 끌어올려 상위 컴포넌트의 state를 업데이트하거나, React의 경우 props를 제어하는 함수를 하위 컴포넌트에 전달해서 props를 변경합니다.



**Q. axios와 fetch가 무엇인지 설명해보세요.**

Fetch는 ES6부터 들어온 JS의 내장 라이브러리입니다. 내장 라이브러리이기 때문에 별도의 Import없이 사용 가능하지만 상대적으로 axios에 비해 기능이 부족하고, Promise를 기반으로 만들어졌기 때문에 데이터 다루기에 편리합니다. 

axios는 Node.js와 브라우저를 위한 Promise API를 활용하는 HTTP 통신 라이브러리입니다. 비동기로 HTTP 통신을 할 수 있으며 Promise 객체를 리턴하기 때문에 response 데이터를 다루기 쉽습니다. 하지만 fetch와 다르게 별도의 모듈 설치 과정이 필요합니다.



**Q. React Hooks에 대해 설명해보세요.**

리액트 클래스형 컴포넌트에서 이용하던 코드를 작성할 필요 없이 함수형 컴포넌트에서도 다양한 기능을 사용할 수 있게 만들어준 라이브러리입니다. 종류로는 `useState`, `useEffect`, `useMemo`, `useRef`, `useCallback` 등이 있습니다.

먼저 `useState`는 현재 상태값과 setter 함수를 사용하여 데이터를 다룰 수 있도록 해줍니다. `useEffect`는 기존 클래스형 컴포넌트에서 사용했던 `componentDidMount`, `componentDidUpdate`, `componentWillUnmount` 를 하나의 API로 통합한 것으로 컴포넌트의 생명주기와 비슷한 역할을 합니다. `useRef`는 DOM 요소에 접근하기 위해 사용되고, `useMemo`와 `useCallback`은 컴포넌트의 성능을 최적화하기 위한 hooks로, 각 메모이제이션된 값과 함수를 반환한다는 특징을 가지고 있습니다.



**Q. 상태관리 라이브러리에 대해 설명해보세요.**

만약 게시판을 만들때 상태관리 라이브러리를 사용하지 않는다면 여러 컴포넌트가 층층이 중첩되어 많은 props 과정으로 데이터를 자식 컴포넌트에게 넘겨주게 됩니다. 이런 과정은 비효율적으로, props drilling issue가 발생하게 됩니다. 이런 현상을 방지하기 위해 사용하는 것이 상태관리 라이브러리로, 이를 통해 어떤 컴포넌트에서든 바로 state에 접근이 가능해집니다. 



**Q. 리액트 상태관리에 대해 설명해보세요.**

큰 종류로 Context API, Redux, Recoil 등이 있습니다.

먼저 Context API는 외부 라이브러리 없이 상태 관리가 가능해 소규모 프로젝트에서 적절한 상태관리 라이브러리입니다. useReducer를 사용하여 redux와 비슷한 형태로 관리할 수 있지만 비동기 처리가 어렵다는 문제가 있습니다. 또한 상태값을 변경하면 Provider로 감싼 모든 컴포넌트가 리렌더링된다는 문제가 발생하여 성능 최적화가 별도로 필요합니다.

Redux는 여러 컴포넌트에서 사용되는 state를 분리 통합하여 관리할 수 있게 하고 애플리케이션의 안정성을 높일 수 있는 라이브러리입니다. 단방향 데이터 흐름을 가지고 있고, 비동기가 지원되지 않기 때문에 별도의 라이브러리 추가가 필요합니다.

Recoil은 atoms과 selectors로 구성된 비교적 간편한 상태관리 라이브러리입니다. 



**Q. 리액트 HOC에 대해 설명해보세요.**

고차 컴포넌트는 컴포넌트를 가져와 새 컴포넌트를 반환하는 함수입니다. 보통 클래스형 컴포넌트에서 리액트 생명주기를 고려한 재사용 가능한 로직을 만들기 위해 사용되었지만, 함수형 컴포넌트에서는 거의 대부분 리액트 훅스로 대체 가능하다는 특징이 있습니다.



**Q. 제어 컴포넌트와 비제어 컴포넌트의 차이에 대해 설명해보세요.**

제어 컴포넌트는 사용자의 입력을 기반으로 자신의 state를 관리하고 업데이트합니다. 일반적으로 state와 그를 변경하는 setState 함수로 구성되어 있고, 이렇게 React에 의해 값이 제어되는 입력 폼 엘리먼트를 의미합니다.

비제어 컴포넌트는 기존의 바닐라 자바스크립트와 크게 다르지 않은 방식으로, setState를 사용하지 않고 ref를 사용해서 값을 얻습니다. 값이 실시간으로 동기화되지 않는다는 특징이 있으며, 즉각적인 피드백이 불필요하고 제출시에만 값이 필요한 경우 사용합니다.



**Q. 클래스형 컴포넌트와 함수형 컴포넌트에 대해 설명해보세요.**

클래스형 컴포넌트는 state와 LifeCycle API의 사용이 가능한 반면, 함수형 컴포넌트는 React Hook으로 lifecycle를 관리합니다. 클래스 컴포넌트는 class와 render 키워드가 필요하고 component를 상속받아야 하지만, 함수 컴포넌트는 함수 자체가 렌더 함수이기 때문에 render 메서드가 필요없고 component도 상속받지 않아도 됩니다. 클래스형보다 선언하기 훨씬 편하기 때문에 최근에는 함수형 컴포넌트를 많이 사용한다고 합니다.



**Q. JSX에 대해 설명해보세요.**

JavaScript에서 XML을 추가한 확장 문법입니다. 모든 항목은 렌더링 되기 전에 문자열로 변환하기 때문에 XSS 공격을 방지할 수 있으며, React 공식에서 권고하는 작성 방식입니다.

JSX를 이용하는 이유를 생각해보면 좋을 것 같다!

- HTML 코드와 비슷하기 때문에 일반 자바스크립트보다 더 익숙하고 가독성이 좋다.
- JSX에 div, span과 같은 HTML 태그를 사용할 수 있으며 개발자가 만든 컴포넌트도 JSX 안에서 작성할 수 있따.



**Q. 리액트 Lifecycle에 대해 설명해보세요.**

생명주기는 컴포넌트가 브라우저상에 나타나고, 업데이트되고, 사라질때 호출하는 메서드를 의미합니다. 클래스형 컴포넌트에서만 사용할 수 있고, 함수형 컴포넌트에는 생명주기 메서드가 따로 없기 때문에 React hooks중 하나인 useEffect를 사용하여 비슷한 동작이 되도록 구현합니다. 



**Q. 리액트 리렌더링 조건에 대해 설명해보세요.**

리액트는 컴포넌트의 상태가 변경될 때마다 렌더링을 예약합니다. 상태를 변경한다는 것은 useState 함수를 실행할 때 트리거가 업데이트된다는 것을 의미합니다. 이는 props 여부와 상관없이 모든 하위 컴포넌트들이 리렌더링되기 때문에 react.memo 등을 사용해 모든 자식 컴포넌트 리렌더링되는 현상을 방지합니다. 



**Q. 리액트 렌더링에 대해 설명해보세요.**

컴포넌트가 현재 props와 state의 상태에 기초해 UI를 어떻게 구성할지, 컴포넌트에게 작업을 요청하는 것을 의미합니다. 부모 컴포넌트가 렌더링되면 자식 컴포넌트도 리렌더링되고, 형제 관계의 컴포넌트들끼리는 서로 리렌더링에 영향을 미치지 않습니다. 리액트의 렌더링은 2가지 방식으로, 컴포넌트를 실행하여 리액트 엘리먼트를 리턴하는 컴포넌트 렌더링과 엘리먼트를 DOM에 반영하는 엘리먼트 렌더링으로 구분됩니다.



https://yeoulcoding.me/147