**Q. BOM과 DOM에 대해 설명해주세요 **

BOM과 DOM은 자바스크립트의 최상위 객체인 window를 구성하고 있는 가장 상단의 구조를 의미합니다. 먼저 DOM은 현재 웹페이지를 프로그래밍적으로 제어할 수 있게 해주는 객체 모델을 의미합니다. 구조화된 문서를 표현하는 방식으로, 모든 요소들과의 관계를 부자 관계로 표현할 수 있는 트리 구조로 구성한 것입니다. 반면 BOM은 브라우저의 창이나 프레임을 프로그래밍적으로 제어할 수 있게 해주는 객체 모델을 의미합니다. 이를 통해 브라우저의 새 창을 열거나 다른 문서로 이동하는 등의 기능을 실행시킬 수 있습니다.



**Q. CI/CD에 대해 설명해주세요 **

CI는 빌드 테스트 자동화 과정으로, 개발자를 위한 자동화 프로세스인 지속적인 통합을 의미합니다. 이는 소스 변경 사항을 정기적으로 커밋하여 모든 사람에게 동일한 작업 기반을 제공하는 것으로 볼 수 있습니다.

CD는 배포 자동화 과정으로 지속적인 서비스 제공 혹은 지속적인 배포를 의미합니다. 

CI/CD의 예시로는 젠킨스, 깃헙 액션 등이 있으며 CI/CD를 사용하지 않는다면 많은 개발자들이 깃 통합 과정에서 많은 에러를 만나 디버깅하는데 시간이 소요되지만 CI/CD를 통해 코드 머지 이후의 과정이 자동적으로 deploy 됩니다.



**Q. CSR과 SSR에 대해 설명해주세요 **

먼저 CSR은 클라이언트단에서 렌더링이 일어나는 과정을 의미합니다. 사용자가 웹사이트에 요청을 보내면 CDN이 HTML파일과 JS 링크를 클라이언트에게 보냅니다. 자바스크립트 코드가 실행되면 데이터를 불러오기 위한 API가 호출되고 불러와진 데이터는 페이지에 깔려서 사용자와 상호작용이 가능해집니다. 

반면 SSR은 서버 사이드 렌더링으로, 서버에서 렌더링이 일어나는 과정을 의미합니다. 사용자가 웹사이트에 요청을 보내면 서버는 즉시 렌더링 가능한 HTML 파일을 만들어냅니다. 클라이언트에 이 파일을 전달하면 렌더링 준비가 되어있기 때문에 HTML은 즉시 렌더링되지만 조작 자체는 불가능한 상태입니다. 이때 클라이언트가 자바스크립트를 다운받고 코드를 실행하면 상호작용이 가능해집니다. 

전반적으로 CSR은 HTML,CSS,JS 다 불러오기 때문에 초기 화면 로드가 느리지만 SSR은 즉시 렌더링 가능한 HTML 파일을 만들기 때문에 SSR이 빠릅니다. 하지만 첫 페이지 이후의 페이지들 면에선 SSR은 전반 과정을 반복해야 하지만 CSR은 나머지 부분을 구성하는 코드만 실행하면 되기 때문에 빠르다고 볼 수 있습니다.



**Q. CDN이 무엇인지 설명해주세요 **

CDN은 유저의 요청에 물리적으로 가까운 서버에서 요청에 응답하는 방식으로, 데이터 사용량이 많은 애플리케이션의 웹 페이지 로드 속도를 높이는 상호 연결된 서버 네트워크를 의미합니다.



**Q. CSS 애니메이션과 JS 애니메이션의 차이점에 대해 설명해주세요 **

간단한 애니메이션 효과의 경우 CSS로 할 수 있습니다. CSS에 transition, animation 키포인트 같은 키워드가 있기 때문에 외부 라이브러리를 사용하지 않고 직관적인 애니메이션 표현이 가능합니다. 또한 메인 스레드가 아닌 별도의 컴포지터 스레드에서 그려지기 때문에 메인 스레드에서 작업하는 JS보다 더 효율적인 장점이 있습니다.

반면 좀 더 인터랙티브한 디자인은 자바스크립트 코드로 가능합니다. 바닐라 자바스크립트로 구현한다면 60fps가 유지되지 않지만 RequestAnimationFrame을 통해 60fps 구현이 가능합니다. 크로스 브라우징 측면에서 브라우저 호환성이 좋은 JS 코드로 작성하는 것이 더 좋습니다.



**Q. 모듈 번들러와 트랜스파일러에 대해 설명해주세요 **

먼저 모듈 번들러는 자바스크립트 모듈을 브라우저에서 실행할 수 있는 단일 자바스크립트 파일로 묶는데 사용되는 도구를 의미합니다. 현대의 프론트엔드 개발은 모듈단위로 파일을 엮어서 하는 방식인데, 수많은 모듈 순서 처리 방식이나 모듈이 많아질수록 HTTP 요청의 수가 늘어남으로 생기는 오버헤드 현상 등의 문제점이 발생합니다. 모듈 번들러는 이러한 문제를 해결하여 하나의 단일 JS 파일 로드만으로 애플리케이션을 빠르게 동작시킬 수 있습니다. 예시로는 webpack, rollup이 있습니다.

반면 트랜스파일러는 특정 언어로 작성된 코드를 같은 언어로 변환해주며 문법적인 부분을 통일시켜주는 역할을 합니다. 예시로는 타입이 있는 자바스크립트를 자바스크립트 언어로 바꿔주는 TS, SCSS를 CSS로 바꿔주는 SASS, ES6 문법을 ES5 문법으로 바꿔주는 Babel 등이 있습니다.



**Q. 브라우저 렌더링 과정에 대해 설명해주세요 **

브라우저가 페이지를 렌더링하려면 가장 먼저 HTML 코드를 파싱하여 DOM 트리로, CSS를 파싱하여 CSSOM 트리를 생성합니다. 여기서 파싱이란 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 과정을 의미합니다.  이렇게 DOM 트리와 CSSOM 트리가 만들어지면 이를 결합해 렌더링 트리가 완성되고, 이 렌더링 트리가 각 노드의 위치와 크기를 계산하는 레이아웃 과정을 거칩니다. 이후 계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고, 레이어를 만듭니다. 만들어진 모든 레이어를 병합해 실제 화면에 나타내는 과정으로 렌더링이 이루어집니다.



**Q. 자바스크립트 엔진이 코드를 실행하는 과정에 대해 설명해주세요 **

브라우저마다 자바스크립트 엔진의 종류가 다른데, 일반적으로 많이 사용하는 구글 크롬과 Node.js는 V8, Apple safari는 Javascript Core를 사용합니다. 먼저 소스코드를 만나면 파싱하여 AST로 변환하고, 인터프리터는 이 AST를 기반으로 바이트코드를 생성합니다. 인터프리터가 바이트코드를 실행할 때, 자주 사용되는 함수 등이 있는 프로파일링 데이터와 같이 최적화 컴파일러에게 보냅니다. 최적화 컴파일러는 프로파일링 데이터를 기반으로 최적화된 코드를 생성합니다. 하지만, 프로파일링 데이터 중 잘못된 부분이 있다면 최적화를 해체하고 다시 바이트코드를 실행해서 이전 동작을 반복합니다.



**Q. 동일출처정책에 대해 설명해주세요 **

Same Origin Policy라고 해서, 한 Origin에서 로드된 문서 또는 스크립트가 다른 Origin의 리소스와 상호작용할 수 있는 방법을 제한하는 중요한 보안 메커니즘을 의미합니다. 여기서 Same origin이란 두 개의 url이 존재할 때 프로토콜, 포트, 호스트가 동일한 경우를 의미합니다. 이 동일출처정책을 통해서 다른 사이트 간의 리소스 공유를 막아 민감 정보가 타 사이트에 새어나가는 것을 방지할 수 있습니다. 

서버와 클라이언트의 origin이 다른 경우는 두 가지 방법을 통해 해결 가능한데, 먼저 첫 번째는 프록시를 이용하여 전체 url 경로를 같게 만들어주는 것입니다. 두 번째는 CORS로, 추가 HTTP 헤더를 사용하여 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 리소스에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제를 사용하는 것입니다. 



**Q. XSS와 CSRF에 대해 설명해주세요 **

먼저 XSS는 Cross Site Scripting이라고 하여, 게시판이나 웹 메일 등에 스크립트 코드를 몰래 심어 의도치 않은 기능이 작동하도록 하는 공격을 의미합니다. GET 메서드를 사용하는 등 일반적으로 피해자가 스스로 작동해 1회성의 공격으로 간주되는 반사형 XSS 공격과 웹사이트의 모든 HTTP 응답을 감염해 지속적으로 공격을 가하는 영구적 XSS, 그리고 DOM 환경에서 악성 URL을 통해 사용자의 브라우저를 공격하는 DOM based XSS 등이 있습니다. 예방하기 위해서는 보안 라이브러리를 사용하거나 입출력 값 검증 및 무효화 등이 있습니다.

CSRF는 사이트 간 요청 변조라 하여 인터넷 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 통해 특정 웹사이트에 요청하게 하는 공격 방식을 의미합니다. 대응하기 위해서 CSRF 토큰을 사용하거나 캡차를 사용하여 사용자를 인증하는 방법 등이 있습니다.

이 둘은 여러 차이점이 있는데, 먼저 XSS는 인증된 세션 없이도 공격 가능하지만 CSRF는 사용자가 로그인된 세션을 악용한다는 점이 있습니다. 그리고 XSS는 사용자가 특정 사이트를 신뢰한다는 사실을 이용하지만 CSRF는 사이트가 사용자를 신뢰하기 때문에 일어나는 현상이라고 볼 수 있습니다. 또한 XSS는 사용자의 정보를 탈취하기 위함이지만 CSRF는 사용자의 금품 구매 등 특정 행위를 위해 수행하는 공격입니다.



**Q. DOCTYPE에 대해 설명해주세요 **

Document Type의 약자로, HTML이 어떤 버전으로 작성되었는지 미리 선언하여 웹브라우저가 내용을 올바르게 표시할 수 있도록 해주는 것입니다. 일반적으로 ! Doctype으로 선언하는데 이를 하지 않으면 호환모드로 동작하며, 호환모드로 동작하면 모든 브라우저에서 문서를 표현하는 형식이 다르기 때문에 크로스 브라우징 이슈가 발생하게 됩니다. 즉 doctype은 html 문서가 어떤 형식을 따르는지 문서 형식 정의를 지정하는 것을 의미합니다.



**Q. script, script async, script defer에 대해 설명해주세요 **

script는 HTML 파싱이 중단되고 즉시 스크립트가 로드되며 로드된 스크립트가 실행되고 파싱이 재개됩니다.

script async 는 HTML 파싱과 병렬적으로 로드되는데, 스크립트를 실행할 때는 파싱이 중단되므로, 다른 스크립트가 의존하지 않는 독자적인 스크립트를 로드할 때 적합한 방식입니다. 

script defer는 HTML 파싱과 병렬적으로 로드되는데, 파싱이 끝나고 스크립트를 로드하는 방식을 의미합니다. 



**Q. local storage, session storage, cookie에 대해 설명해주세요 **

먼저 local storage는 클라이언트의 컴퓨터에 데이터를 저장하는 방법을 의미합니다. 쿠키와 유사하지만 일반적으로 key,value 쌍으로 데이터를 저장하는 방식입니다. 

session storage는 로컬 저장소와 유사하지만 현재 세션에 대한 데이터만 저장하고 브라우저를 닫으면 삭제됩니다. 쿠키를 기반으로 동작하긴 하지만 사용자 정보를 서버에서 관리하고, 창을 끄면 삭제된다는 점에서 보안성이 더 있습니다.

마지막으로 cookie는 클라이언트 측 컴퓨터에 저장되는 작은 데이터 조각을 의미합니다. 브라우저는 그 데이터 조각들을 저장해놓았다가, 동일한 서버에 재요청 시 저장된 데이터를 함께 전송합니다. 



**Q. 시맨틱 마크업에 대해 설명해주세요 **

시맨틱 마크업은 의미론적인 HTML 태그 문서 작성을 의미합니다. 예시로는 header, article, section, footer 등이 있으며, 이러한 태그를 통해 웹 접근성에 효율적이고 코드 가독성이 높아집니다.



**Q. 표준모드와 호환모드에 대해 설명해주세요 **

브라우저를 어떤 방식으로 렌더링할지에 따라 선택 가능한데, 먼저 호환모드로 렌더링하게 되면 여러 브라우저마다 맞는 방식으로 렌더링되게 됩니다. 

반면 표준모드는 일반적으로 doctype을 가지고 있다면 실행되고, CSS2 스펙에 따라 CSS가 적용되었음을 의미합니다. 이는 또 다시 완전 표준모드와 거의 표준모드로 나뉘는데, 완전 표준모드는 HTML, CSS 에 의해 웹페이지가 표시되는 방식이고 거의 표준모드는 소수가 호환모드로 표시되는 것을 의미합니다.



**Q. 시맨틱 마크업에 대해 설명해주세요 **



**Q. 시맨틱 마크업에 대해 설명해주세요 **



**Q. 시맨틱 마크업에 대해 설명해주세요 **