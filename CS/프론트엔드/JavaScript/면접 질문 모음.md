**Q. this 바인딩이 무엇인지 설명해보세요. **

먼저 this란 Object를 참조하는 keyword를 의미하며, 파이썬 언어로는 self와 같은 역할을 한다고 볼 수 있습니다. 자바스크립트에서 this가 참조하는 것은 함수가 호출되는 방식에 따라 결정되는데, 이를 this 바인딩이라고 합니다. this 바인딩이 일어나는 상황 중 가장 먼저 바인딩이 일어나는 순위를 매겨보자면, new 바인딩, 명시적 바인딩, 암시적 바인딩 순으로 일어납니다. 먼저 new 바인딩은 new를 사용했을 때 해당 객체로 바인딩 됩니다. 명시적 바인딩은 call, apply, bind와 같은 명시적 바인딩을 사용했을 때 인자로 전달된 객체에 바인딩되고, 마지막으로 암시적 바인딩은 객체의 메소드로 호출할 경우 해당 객체에 바인딩되는 경우를 의미합니다. 그 외에 일반적인 경우 브라우저라면 window 객체에, nodeJS에서는 global에 바인딩됩니다.



**Q. 호이스팅이 무엇인지 설명해보세요. **

호이스팅이란 변수 및 함수의 선언문이 스코프 내 최상단으로 끌어올려진 것 같은 현상을 의미합니다. `var`로 변수를 선언하는 경우엔 자바스크립트 엔진이 해당 코드를 실행하기 전 먼저 execution context를 만들기 때문에 해당 변수의 값을 참조할 수 있어, 호이스팅이 됩니다. 반면 `const`나 `let`으로 변수를 선언할 경우 값이 초기화되어 있지 않기 때문에 호이스팅이 안돼 referenceError가 발생합니다. 마찬가지로 함수에서도 함수 선언식은 variable environment에 저장되기 때문에 호이스팅이 가능하지만 함수 표현식은 variable environment에 undefined로 저장되어 typeError가 발생합니다.



**Q. 실행 컨텍스트에 대해 설명해보세요 **

실행 컨텍스트는 코드의 실행 환경에 대한 여러가지 정보를 담고 있는 개념을 의미합니다. 엔진이 스크립트 파일을 실행하기 전에 글로벌 실행 컨텍스트가 생성되고, 함수가 호출될 때마다 함수 실행 컨텍스트가 생성됩니다. 실행 컨텍스트가 생성되면 흔히 콜스택이라고 불리는 실행 컨텍스트 스택에 쌓이게 됩니다. 

실행 컨텍스트는 lexical 환경과 variable 환경, this 바인딩으로 구성되어 있습니다. 먼저 lexical 환경은 변수 및 함수 등의 식별자 및 외부 참조에 관한 정보를 가지고 있는 컴포넌트입니다. variable 환경은 기본적으로 lexical 환경과 동일한 성격을 띠지만 var로 선언된 변수만 저장한다는 점에서 차이점이 있습니다. 마지막으로 this 바인딩은 실행 컨텍스트가 생성될 때마다 this 객체에 어떻게 바인딩이 되는지를 나타내는 것입니다.



**Q. 프로토타입 상속이 어떻게 작동하는지 설명해보세요 **

자바스크립트의 모든 객체는 자신의 원형이 되는 객체를 가지며 이를 프로토타입이라고 정의하며, 비유적 표현으로 유전자를 찾는 속성으로 볼 수 있습니다. 객체의 프로퍼티에 접근할 때, 해당 객체에 프로퍼티가 없으면 자바스크립트 엔진은 프로토타입 체인을 통해 프로퍼티를 찾습니다. 프로토타입 체인은 프로토타입 링크를 타고 올라가면서 해당 프로퍼티를 찾는 방식을 의미합니다.



**Q. IIFE에 대해 설명해보세요 **

IIFE는 즉시 함수 호출 표현식으로, 자바스크립트 이벤트 루프에서 호출되는 순간 실행되는 함수를 의미합니다. 형태는 첫 번째 괄호로 둘러싸인 익명 함수 부분과 두 번째 괄호로 둘러싸인 즉시 실행 함수 생성 파트입니다. IIFE를 사용하면 async를 사용할 수 있어 비동기 함수 실행이 가능하고, IIFE에서 변수를 정의하면 함수 내에서만 직접 접근이 가능해 전역 스코프 오염방지가 가능하다는 특징이 있습니다. 



**Q. 클로저에 대해 설명해보세요 **

클로저는 외부 함수보다 내부 함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부함수가 호출되더라도 외부함수의 지역변수에 접근할 수 있는 함수를 의미합니다. 이는 내부 함수가 본인이 선언되었을 때의 환경인 렉시컬 환경을 기억하기 때문에 자신이 선언되었을 때의 환경 밖에서 호출되어도 그 환경에 접근할 수 있습니다. 



**Q. Ajax에 대해 설명해보세요 **

Ajax는 비동기 웹 응용 프로그램을 만들기 위해 클라이언트 측에서 사용되는 웹 개발 기법입니다. 작동 방식은 먼저 사용자가 AJAX가 적용된 UI와 상호작용하면, 서버에 AJAX 요청을 보내게 됩니다. 서버는 DB에서 데이터를 가져와 JS 파일에 정의돼 있는대로 HTML/CSS를 사용해 만든 DOM 객체를 UI에 업데이트 시킵니다. 이러한 Ajax를 사용하면 페이지 이동 없이 필요 컴포넌트만 업데이트 가능하고 비동기 요청이 가능하다는 장점이 있지만, HTTP 클라이언트의 기능이 한정되어 있고 Script로 작성되므로 디버깅이 용이하지 않다는 단점이 있습니다. 일반적으로 XMLHttpRequest를 사용했지만 최근엔 FetchAPI를 사용하여 더 직관적으로 사용할 수 있습니다. 



**Q. ==과 ===의 차이점에 대해 설명해보세요 **

==는 추상 동등 연산자이고 ===는 완전 동등 연산자를 의미합니다. 추상 동등 연산자는 타입 변환이 필요한 경우 타입 변환을 한 후에 동등한지 비교하지만, 완전 동등 연산자는 타입 변환을 하지 않으므로 두 값이 같은 타입이 아닌 경우 false를 반환합니다. 



**Q. 엄격모드에 대해 설명해보세요 **

엄격 모드는 자바스크립트가 기존에 무시해주던 에러를 잡아주는 모드를 의미합니다. 스크립트의 시작 혹은 함수 시작 부분에 "use strict"를 선언하면 엄격 모드로 코드 작성이 가능하며, 한 번 엄격모드로 시작된 코드는 되돌릴 수 없다는 특징이 있습니다. 이 엄격모드로 코드를 작성하면 실수로 전역변수를 만드는 것이 불가능하며, 암묵적으로 실패한 예외를 throw하지 못하는 할당을 만들고 헷갈리거나 잘 모르는 기능을 사용할 수 없게 한다는 장점이 있습니다. 하지만 엄격 모드를 사용하면 더 극적으로 좋은 코드로 만들어주는 것은 아니며, 서로 다른 엄격 모드로 작성된 스크립트를 병합하면 또 다른 문제가 발생할 수 있다는 특징이 있습니다.



**Q. SPA에 대해 설명해보세요 **

SPA는 single page application의 줄임말로, 말 그대로 하나의 페이지를 사용하는 애플리케이션을 의미합니다. client-side rendering을 통해 서버가 해야할 화면 구성을 클라이언트가 수행하므로 서버 부담이 경감되며 페이지 전체가 바뀌는 것이 아닌 필요한 컴포넌트만 부분 교체하면 되므로 효율성이 높아집니다. 반면 여러 페이지에 필요한 프레임워크, 에셋 로드로 인해 초기 페이지로드가 무거워지고 검색 엔진 최적화가 어려워진다는 단점이 있습니다.



**Q. Callback 대신에 Promise를 사용할 때의 장단점에 대해 설명해보세요**

가독성이 떨어지는 콜백 지옥을 피할 수 있고, .then을 이용하여 가독성 좋은 연속적인 비동기 코드를 쉽게 작성할 수 있습니다. 반면 ES2015를 지원하지 않는 이전 브라우저에서 이를 사용하기 위해서는 polyfill을 로드해야 합니다.



**Q. Promise에 대해 설명해보세요 **

Promise란 비동기 처리를 위해 사용되는 객체로, 생성자 함수를 통해 Promise 객체를 만들어낼 수 있습니다. 생성자 함수의 첫 번째 인자로 콜백 함수를 넘겨야 하며, 이 인자로는 성공했을 때 실행시킬 함수인 resolve 함수와 실패했을 때 실행시킬 reject 함수를 인자로 넣어줍니다. Promise의 상태는 총 3가지로, 이행하지도 거부하지도 않은 초기 상태인 pending과 연산이 성공적으로 완료된 fulfilled, 그리고 연산이 실패한 rejected 상태로 나뉘어집니다. Promise의 내부적으로 비동기 처리된 결과 값들을 받아 별도로 처리하기 위해선 .then과 .catch 메서드를 사용해야 합니다. 



**Q. 이벤트 루프에 대해 설명해보세요 **

이벤트 루프는 콜백 이벤트 큐에서 하나씩 꺼내서 동작시키는 루프를 의미합니다. 일반적으로 자바스크립트는 싱글 스레드 기반 언어이기 때문에 한번에 하나씩 작업을 진행하는데, 이 이벤트 루프를 이용해서 비동기 방식으로 동시성을 지원합니다. 이벤트 루프는 매크로 태스크 큐와 마이크로 태스크 큐 이 두 큐를 감시하고 있다가 콜 스택이 비게 되면 콜백함수를 하나씩 꺼내와서 실행시킵니다. 이때 마이크로 태스크 큐가 매크로 태스크 큐보다 우선순위를 가지게 되므로 마이크로 태스크 큐의 콜백 함수를 전부 실행하고 나서 매크로 태스크 큐의 콜백함수를 실행합니다. 



**Q. var, let, const에 대해 설명해보세요 **

var는 재선언되고 업데이트될 수 있어 이미 선언했던 변수명을 모르고 또 사용할 경우 기존의 변수는 전혀 다른 값을 가지게 돼 다양한 로직들에 치명적인 문제가 생깁니다. ES6 등장 이전엔 var로 변수를 선언하는 것이 지배적이었지만 현재는 var를 거의 사용하지 않습니다.  

let은 업데이트는 되지만 재선언이 불가능하고, 변수가 범위 내에서만 존재하기 때문에 이전에 이미 사용한 적이 있는 변수명에 대해서 더 이상 신경쓰지 않아도 됩니다. 

반면 const는 일정한 상수 값을 유지해주며 업데이트와 재선언 둘 다 불가능합니다. 세 가지 모두 최상위로 호이스팅 가능하며, var는 undefined로 초기화되지만 let과 const는 초기화되지 않는다는 특징이 있습니다. 더불어 var과 let은 초기화하지 않은 상태에서 선언할 수 있지만, const는 선언 중에 초기화해야 합니다.



**Q. Scope에 대해 설명해보세요 **

스코프란 자바스크립트 엔진이 참조의 대상이 되는 식별자를 검색할 때 사용하는 규칙의 집합을 의미합니다. 



**Q. 네이티브 객체와 호스트 객체에 대해 설명해보세요 **

네이티브 객체는 자바스크립트 언어 규약으로 정의되어진 객체로, 애플리케이션 전역의 공통 기능을 제공합니다. 종류로는 Object, Number, Boolean, Date 등의 값이 있습니다.

반면 호스트 객체는 자바스크립트를 실행하는 환경에 종속된 객체로 그 환경에서만 찾아볼 수 있습니다. 호스트 객체의 종류로 모든 객체의 유일한 최상위 객체인 전역 개체, 브라우저 탭의 모델을 생성하는 BOM, 그리고 현재 웹페이지의 모델을 생성하는 DOM으로 볼 수 있습니다.



**Q. 모듈 시스템에 대해 설명해보세요 **

모듈이란 먼저 여러 기능들에 관한 코드가 모여있는 하나의 파일을 의미합니다. 모듈화가 잘 되어있다면 유지보수성이 뛰어나고, 재사용성이 높다는 장점이 있습니다. 이러한 모듈의 종류로는 AMD, CommonJS, UMD 그리고 ESModule이 있습니다. 

먼저 CommonJS는 NodeJS 환경에서 자바스크립트 모듈을 사용하기 위해 만들어진 시스템을 의미합니다. 외부에서 사용할 수 있도록 내보낼 때는 exports와 같은 키워드를, 외부에서 모듈을 불러올 때 require를 사용하여 내보내고 불러옵니다.

AMD는 비동기적인 모듈 선언을 의미합니다. 여러 파일을 비동기적으로 병렬 다운로드가 가능해져 상대적으로 로딩 시간이 단축되는 효과를 가지고 오며, define, require 함수를 통해 구현합니다. CommonJS는 노드 환경에서 많이 사용된다면 AMD는 RequireJS라는 스크립트로서 브라우저 환경에서 많이 사용됩니다

UMD는 AMD와 CommonJS가 호환될 수 있도록 만들어진 모듈 시스템입니다. 하나로 정해진 코드라기 보다는 디자인 패턴에 더 가까우며 AMD, CommonJS 그리고 기존처럼 window에 추가하는 방식까지 모든 경우를 커버할 수 있는 모듈을 작성하는 것을 의미합니다.

마지막으로 ESModule은 원래는 Babel과 같은 트랜스파일러를 사용했어야 했는데, NodeJS 버전 13.2부터 ES 모듈 시스템에 대한 정식 지원이 시작됨에 따라 다른 도구 없이 NodeJS에서 손쉽게 ESModule를 사용하여 모듈 기능을 이용할 수 있습니다.



**Q. 콜 스택과 힙에 대해 설명해보세요 **

자바스크립트 엔진은 콜 스택과 메모리 힙으로 구성되어 있습니다. 콜 스택은 원시타입 값과 함수 호출의 실행 컨텍스트를 저장하는 곳이고 힙은 객체, 배열과 같이 크기가 동적으로 변할 수 있는 참조타입 값을 저장하는 곳입니다. 



**Q. new에 대해 설명해보세요 **

자바스크립트에서 new 연산자를 통해 함수를 생성자로 호출할 수 있고, 그에 따라 새로운 객체를 생성할 수 있습니다. new는 다음과 같은 과정으로 이루어지는데, 먼저 빈 객체를 생성하고 [[Prototype]] 속성을 생성자 호출할 함수의 prototype 속성으로 지정 후 해당 객체를 this로 지정합니다. 함수의 리턴 값이 원시값이라면 새로 만들어진 객체가 리턴되고 리턴값이 객체라면 해당 객체가 리턴됩니다.



**Q. async와 await에 대해 설명해보세요 **

Promise를 좀 더 편하게 사용할 수 있는 방법으로 async, await 함수를 통해 사용합니다. 먼저 async 함수는 Promise를 리턴하는 함수로, return된 값이 Promise가 이행되었을때의 값으로 들어갑니다. await는 async 함수 내부에 사용되는 키워드로, Promise 객체 앞에 붙어 이행될 때까지 기다리고, 이후 resolve 함수를 통해 반환한 값을 반환합니다. await을 통해 비동기 처리를 동기적으로 처리할 수 있게 되며, 그 결과값을 특정 변수로 받을 수 있게 되어 가독성이 좋아진다는 장점이 있습니다.

콜백 지옥 설명도 얘기해주기!!!

콜백지옥이란, 콜백 함수를 익명 함수로 전달하는 과정에서 또 다시 콜백 안에 함수 호출이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상을 의미합니다.



**Q. 이벤트 버블링을 막는 방식에 대해 설명해보세요 **

부모에게 이벤트 전파되는 것을 막는 stopPropagation이나 현재 이벤트의 기본 동작을 중단하는 preventDefault 등을 사용해 이벤트 버블링을 막습니다.



**Q. 이벤트 버블링과 이벤트 캡처링에 대해 설명해보세요 **

이벤트 버블링은 하위 엘리먼트에 이벤트가 발생할 때 그 엘리먼트부터 시작해서 상위요소까지 이벤트가 전달되는 방식이고, 이벤트 캡처링은 하위 엘리먼트에 이벤트 핸들러가 있을 때 상위 엘리먼트부터 이벤트가 발생하기 시작해서 하위 엘리먼트까지 이벤트가 전달되는 방식을 의미합니다.



**Q. 이벤트 위임에 대해 설명해보세요 **

이벤트 위임이란 이벤트 리스너를 하위 요소에 일일이 추가하는 대신 상위 엘리먼트에 추가해 한 번에 하위 요소들의 이벤트를 관리하는 기법입니다. 리스너는 DOM의 이벤트 버블링으로 인해 하위 요소에서 이벤트가 발생될 때마다 실행됩니다. 상위 요소에 하나의 단일 핸들러만 사용하기 때문에 메모리 사용 공간이 줄어들고 코드가 훨씬 깔끔해진다는 장점이 있습니다.