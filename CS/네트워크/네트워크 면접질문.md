**Q1. OSI 7계층에 대해 설명해주세요.**

모든 네트워크 통신에서 생기는 여러 충돌 문제를 완화하기 위하여, 국제표준기구에서 표준화된 네트워크 구조를 제시한 기본 모델입니다. 

가장 하단의 물리계층은 물리적으로 노드를 전송매체와 연결하기 위한 특성과 규칙입니다. 예시로는 케이블 규격, 신호의 전압, 라인이 몇 가닥 있는지 등을 볼 수 있습니다.

다음은 물리적 전송 오류를 해결하는 데이터 링크 계층, 네트워크 주소 개념을 가지고 호스트 간 올바른 데이터 전송 경로를 선택하는 네트워크 계층순입니다.

다음은 송수신 프로세스 종단간 연결 기능을 지원해 데이터를 안전하게 전송하는 전송 계층, 대화 개념을 지원해 논리적 연결을 지원하는 세션 계층, 데이터를 표현하는 방식을 뜻하는 표현 계층, 마지막으로 이전의 모든 단계를 제외한 모든 응용 서비스를 지원하는 응용 계층이 있습니다. 

  

**Q2. TCP와 UDP 방식의 차이점을 설명해주세요.**

TCP와 UDP는 전송계층에서 사용하는 프로토콜의 종류입니다.

TCP는 연결이 설정되면 데이터를 양방향으로 전송할 수 있는 연결 지향형 프로토콜로, 에러 없이 패킷이 신뢰할 수 있게 전달되었는지 보증해주는 역할을 합니다. 데이터의 분실, 중복, 순서바뀜 등을 흐름제어, 혼잡제어를 통해 자동으로 보정해줘서 데이터를 정확하게 전달해줍니다.

반면 UDP는 비연결형 프로토콜로, TCP에 비해 데이터를 빠르게 전달해준다는 장점이 있어 실시간 방송에서 쓰이는 프로토콜입니다. 대신 데이터의 손실이나 순서 바뀜 등의 문제가 발생할 수 있다는 단점이 있습니다.



**Q3. TCP의 3way-handshake와 4-way handshake에 대해 설명해주세요.**

TCP는 연결 지향형 프로토콜로, 호스트 간 신뢰성 있는 전달과 흐름 제어를 가능하게 합니다. 이런 TCP는 장치들 사이 논리적 접속 성립을 위해 3way handshake를 먼저 사용합니다. 이는 데이터를 전송하기 전, 정확한 데이터 전송을 보장하기 위해 사전에 세션을 수립하는 과정입니다. 예를 들어 A 클라이언트가 B 서버에 접속 요청을 하기 위해 SYN 패킷을 보냅니다. B는 이를 받고 요청을 수락한다는 ACK와 SYN flag 패킷을 발송하고, 이를 받는 A는 ACK를 다시 보내 연결이 성립됩니다.

세션을 종료하기 위해 사용되는 방식이 4 way handshake입니다. 이는 A 클라이언트가 B 서버에게 연결 종료를 위해 FIN flag를 보내면 B는 확인메시지를 먼저 보내고, 통신이 다 끝나고 난 뒤 FIN flag를 보냅니다. A가 이에 확인 메시지를 보내며 4단계로 세션을 종료하는 방식을 의미합니다.



**Q4. DNS에 대해 설명해주세요.**

Domain Name System의 약자로, Domain name을 IP 주소로 바꿀 수 있도록 해주는 시스템을 의미합니다. 이를 통해 사용자가 숫자로 된 인터넷 프로토콜 주소 대신 인터넷 도메인 이름과 검색 가능한 URL을 이용하여 웹사이트에 접속 가능합니다.



**Q5. 프록시 서버가 필요한 이유에 대해 설명해주세요.**

서버와 클라이언트 사이에 중계기로서 대리로 통신을 수행하는 것을 프록시라 하고, 이 중계 기능을 하는 것을 프록시 서버라고 합니다. 프록시 서버는 요청된 내용을 캐시에 저장하고 다음에 같은 요청이 들어오면 캐시에 저장된 정보를 제공해 전송시간을 단축해줍니다. 더불어 서버의 IP를 숨기는 것이 가능해 외부로부터 위험을 막아준다는 보안 역할도 수행해줍니다.



**Q6. HTTP와 HTTPS 통신 방식의 차이점에 대해 설명해주세요.**

HTTP 프로토콜은 평문 데이터를 전송하는 프로토콜이기 때문에, 누군가 네트워크에서 신호를 가로채면 내용이 노출되는 보안 이슈가 존재합니다. HTTPS는 HTTP에 Secure, 즉 안전성을 더한 방식으로, 정보를 암호화하는 SSL 프로토콜을 사용해 텍스트를 암호화해준다는 점에서 차이점이 있습니다.



**Q7. HTTP 프로토콜에 대해 설명해주세요.**

HyperText Transfer Protocol의 약자로, 서버/클라이언트 간 자원을 주고받을 때 쓰는 통신 규약을 의미하며, 요청과 응답으로 구성되어 있습니다. 상태를 저장하지 않는 무상태성과 클라이언트의 요청에 맞는 응답을 보낸 후 연결을 끊는 비연결성의 특징을 갖고 있습니다.



**Q8. 무상태와 비연결성에 대해 설명해주세요.**

HTTP 프로토콜의 두 가지 특징으로, 먼저 비연결성은 요청과 응답 이후 자동으로 연결이 끊어지는 비상태 프로토콜을 의미합니다. 무상태성은 HTTP에서 서버가 클라이언트의 상태를 보존하지 않는 프로토콜을 의미합니다. 이 두 특성을 통해 필요한 통신만 하고 해제되기 때문에 여러 클라이언트의 접속을 원활하게 해준다는 장점이 있습니다. 



**Q9. REST API에 대해 설명해주세요.**

REST란 자원의 표현으로 구분하여 해당 자원의 상태를 주고받는 모든 것을 의미합니다. 예를 들어 DB에 학생 정보가 저장되어 있다면, 이 학생들이 자원의 표현으로 볼 수 있습니다. REST API란 이런 REST를 기반으로 두 컴퓨터 시스템이 인터넷을 통해 정보를 안전하게 교환하기 위해 사용하는 인터페이스를 뜻합니다.

❗REST API란, 자원의 이름으로 해당 자원의 상태를 주고 받는 것을 의미합니다. HTTP URI를 통해 자원을 명시하고 HTTP method를 통해 해당 자원에 대한 CRUD operation을 적용할 수 있으며 서버는 요청에 대한 응답으로 JSON, XML과 같은 HTTP Method Payload를 받을 수 있습니다.



**❗❗Q10. 오류 제어와 흐름 제어, 혼잡제어에 대해 설명해주세요.**

오류 제어는 호스트 간 데이터 전송이 일어날 때 데이터의 오류에 관련된 제어를 하는 역할을 합니다. 데이터가 도착하지 않거나, 중복으로 도착하거나, 변형이 일어난 경우를 다 해결해줍니다.

흐름제어는 오류 제어와 함께 데이터 링크 계층에서 제공되며 데이터 프레임의 전송 속도를 조절하는 역할을 합니다. 송신단에서 수신단이 감당할 수 있는 정도의 전송 속도를 유지하며 전송을 해야 하는데, 버퍼의 용량 이상으로 빠르게 수신단이 데이터를 받게 되면 데이터 분실이 일어날 수 있으므로 이러한 속도를 조절해주는 것입니다.

혼잡제어!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



**Q11. ARP와 RARP의 차이점에 대해 설명해주세요.**

ARP는 주소 결정 프로토콜로, 네트워크 상에서 IP주소를 물리적 네트워크 주소로 대응시키기 위해 사용되는 프로토콜입니다.

반면 RARP는 역 ARP로, 물리 네트워크 주소는 알지만 IP 주소를 모르는 경우 서버로부터 IP 주소를 요청하기 위해 사용되는 프로토콜입니다.



**Q12. GET 메서드와 POST 메서드의 차이점에 대해 설명해주세요.**

사용 목적, 요청에 body 유무, 멱등성 관점에서 차이점이 있습니다.

먼저 GET은 서버의 리소스에서 데이터를 요청할 때 사용하고, 파라미터에 요청하는 데이터를 담아 보내기 때문에 body가 없고 조회를 여러 번 요청해도 응답이 똑같기 때문에 멱등성을 가지고 있습니다.

반면 POST는 리소스를 생성/업데이트할 때 사용하고, body에 데이터를 담아보내기 때문에 body가 필요하며 생성,업데이트 용도이기 때문에 멱등이 아닙니다.



**Q13. PUT 메서드와 PATCH 메서드 차이점에 대해 설명해주세요.**

두 메서드 다 리소스의 업데이트를 한다는 공통점이 있지만, PUT은 리소스 모든 것을 업데이트하지만 PATCH는 리소스 일부를 업데이트한다는 차이점이 있습니다.



**Q14. HTTP 상태 코드에 대해 설명해주세요.**

응답 상태 코드는 특정 HTTP 요청이 성공적으로 완료되었는지 알려주고 이러한 응답은 5개의 그룹으로 나누어집니다. 

요청을 받았고, 작업을 진행 중이라는 의미의 100번대, 작업을 성공작으로 받았다는 걸 의미하는 200번대, 이 요청을 완료하기 위해서는 리다이렉션이 이루어져야 한다는 300번대, 요청이 올바르지 않다는 의미의 400번대 그리고 마지막으로 500번대는 서버가 응답할 수 없음을 의미합니다.



**Q15. 쿠키와 세션에 대해서 설명해주세요.**

쿠키는 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일입니다. HTTP에서 클라이언트의 상태 정보를 PC에 저장했다가 필요시 정보를 참조하거나 재사용할 수 있습니다.

반면 세션은 일정 시간 동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 유지시키는 기술입니다. 

HTTP는 연결 해제 후 상태를 저장하지 않는다는 무상태성이라는 특징을 갖고 있는데, 로그인, 장바구니와 같이 상태 정보를 유지해야할 경우가 있기 때문에 쿠키와 세션을 사용합니다.

- 쿠키는 컴퓨터에 저장하고 세션은 서버에 저장한다는 차이점이 있습니다.
- 쿠키는 속도가 빠른 대신 보안 문제가 있고, 세션은 속도가 느리지만 서버에 저장되기 때문에 보안이 우수하다는 차이점이 있습니다.
- 세션이 브라우저가 종료되면 삭제된다는 특징이 있습니다. 그래서 보안적인 측면에서 더 안정적. 세션 ID를 쿠키에 담아서 세션쿠키를 주고받는 



**Q16. SSL과 TLS에 대해 설명해주세요.**

SSL은 Secure socket Layer의 약자로 웹서버와 웹브라우저간의 암호화 통신을 위하여 응용 계층과 TCP/IP 계층에서 동작하는 프로토콜이며, ISO 표준 정식 명칭으로 TLS라 합니다. 사람들에게 공개되는 공개키와 특정인만 갖는 비밀키 암호화를 통해 동작합니다.



**Q17. www.naver.com을 입력하면 어떤 일이 일어나는지 알려주세요.**

사용자가 주소창에 naver를 입력하면 브라우저는 도메인 네임에 대한 IP 주소를 요청하러 갑니다. 이때 naver.com처럼 프로토콜 부분을 생략하고 입력하면 기본적으로 https로 요청됩니다.  이렇게 전달된 도메인 네임은 DNS에서 IP주소로 변환되고, tcp 3 way-handshake를 통해 연결이 수립됩니다. 이 때 네이버 서버에 HTTP request를 보내고, 서버에서 응답을 받으면 이 HTML 문서를 브라우저에 넣어주게 됩니다. HTML 문서를 파싱하여 DOM 트리 구성 및 CSS 파일을 위한 CSSOM 트리가 구축되어, 렌더 트리가 만들어지면 레이아웃이 구성되고 최종적으로 화면에 네이버 화면이 보이게 됩니다.



**Q18. CORS에 대해 설명해주세요.**

Cross Origin Resource Sharing의 줄임말로, 서로 다른 출처 간에 자원을 공유하는 것을 의미합니다. 

SOP라는 보안정책 때문에 원래는 같은 출처 안에서만 리소스 공유가 가능했지만, CORS 라는 예외 사항 덕에 다른 출처에서도 정보를 읽을 수 있게 되었습니다. 

CORS 없이 모든 곳에서 데이터를 요청할 수 있게 된다면, 해킹 등의 보안 문제가 생길 수 있는데 이런 공격을 할 수 없도록 브라우저에서 보호하고, 필요한 경우에만 서버와 협의하여 요청할 수 있도록 하기 위해 필요한 개념입니다.



**Q19. 공인 IP와 사설 IP의 차이에 대해 설명해주세요.**

공인 IP는 ISP가 제공하는 IP 주소이며, 외부에 공개되어 있는 IP 주소입니다. 사설 IP는 일반 가정이나 회사 내 등에 할당된 네트워크 IP 주소이며, IPv4의 주소 부족으로 인해 서브네팅된 IP이기 때문에 라우터에 의해 로컬 네트워크상의 PC나 장치에 할당됩니다.



**Q20. TCP/IP 4계층에 대해 설명해주세요.**

현재의 인터넷에서 컴퓨터들이 서로 정보를 주고받는데 쓰이는 통신규약의 모음으로, 각 계층은 담당하는 위치마다 처리 역할을 구분해 진행함으로 서로 간의 간섭을 최소화하여 사용의 편리성을 높입니다.

1계층은 OSI 7계층의 물리계층과 데이터 링크 계층으로, 물리적으로 데이터가 네트워크를 통해 어떻게 전송되는지 정의합니다. 2계층은 OSI 7계층 중 네트워크 계층이 속한 인터넷 계층으로, IP 패킷을 전송하는 기능과 라우팅 기능을 담당합니다. 3계층은 전송 계층으로, 통신 노드 간 연결을 제어하고 신뢰성 있는 데이터 전송을 담당합니다. 마지막 4계층은 세션 계층, 표현 계층, 응용 계층이 포함된 응용 계층으로 사용자가 소프트웨어 application과 소통하게 해줍니다.



**Q21. CSR과 SSR에 대해 설명해주세요.**

먼저 CSR은 client side rendering이라고 하여, 렌더링이 클라이언트 쪽에서 일어납니다. 서버가 HTTP 요청을 받은 후 클라이언트에 HTML과 JS를 보내주면, 이를 토대로 클라이언트가 렌더링을 시작합니다.

반면 SSR은 server side rendering이라고 하여, 렌더링이 서버에서 일어납니다. 즉 User가 요청을 보내면 즉시 렌더링 가능한 HTML 파일을 만들어 보여주고, 이후 클라이언트가 JS를 다운받고 브라우저가 JS 프레임워크를 실행하고 나면 상호작용이 시작됩니다.



**Q. CSR과 SSR에 대해 설명해주세요.**