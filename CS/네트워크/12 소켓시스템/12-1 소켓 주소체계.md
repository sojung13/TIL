### 소켓

#### 개요

##### 소켓에 대한 역사

- 1983년 BSD 4.2 에 포함된 네트워크 프로그램용 API (Bill Joy)
- AT&T의 경우 1986년 TLI(Transport Layer Interface) 발표\
- X/Open에서 1988년 TLI를 개선하여 XTI(X/Open Transport Interface) 발표
- SUN W/S에 socket 라이브러리를 추가한 BSD UNIX 탑재
- PC용 WinSock 등장



##### 바이트 순서(Byte Order)

- 어떤 값을 메모리에 저장할 때 어떤 방식으로 저장하는가에 따라서 big endian, little endian으로 나누어짐
  - "큰 쪽부터 깨먹을거냐, 작은 쪽부터 깨먹을거냐?" - 걸리버 여행기에서 유례

![image-20230303181847460](../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230303181847460.png)

- 기계별 적용 방식

![image-20230303181902337](../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230303181902337.png)

- 각 방식의 장단점
  - Little endian : 사용시 수학적 연산(형 변환)이 쉬움
  - Big endian : 사용시 숫자 비교가 빠르고, 디버깅 용이

- 통신에서는?
  - Big endian이 네트워크 바이트 순서임
  - Host byte order <-> Network byte order 변환 필수
- 바이트 순서 변환 관련 함수
  - htons(Host to Network Short)
  - htonl(Host to Network Long)
  - ntohs(Network to Host Short)
  - ntohl(Network to Host Long)
- IP 주소, Port 번호는 반드시 바이트 순서 변환을 해서 사용



##### 소켓 주소

- 프로토콜의 종류에 따라 사용하는 주소 체계가 다름

  - AF_UNIX : 한 호스트에 존재하는 프로세스 사이의 통신을 지원
  - AF_INET : 다른 호스트에 존재하는 프로세스 사이의 통신을 지원

- 유닉스 주소 체계

  - AF_UNIX

    - 한 호스트에 존재하는 프로세스 사이의 통신을 지원
    - 주소 체계는 파일 시스템의 경로명을 기반으로 함

  - 주소 체계

    ![image-20230303182210042](../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230303182210042.png)

- 인터넷 주소 체계

  - AF_INET

    - 다른 호스트에 존재하는 프로세스 사이의 통신을 지원
    - 주소 체계는 32비트 IP 주소와 16 비트 포트 번호를 기반으로 함

  - 주소 체계

    ![image-20230303184544788](../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230303184544788.png)

- IPv6에 사용되는 소켓 주소 구조체

![image-20230303184607185](../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230303184607185.png)

- 통합 주소 체계 필요성

  - 프로토콜마다 주소 체계를 지원하는 문법 구조가 다름
  - 문법 구조상 하나의 함수에서 다양한 주소 체계를 지원하는데 어려움이 있음
  - 따라서 모든 주소 체계를 수용할 수 있는 공통 주소 체계가 필요함

- 통합 주소 체계

  ![image-20230303184648620](../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230303184648620.png)

  - 사용 예
    - addr : 주소 공간 자체는 해당 프로토콜의 주소 체계로 선언(인터넷 주소 체계)
    - bind() 함수의 두 번째 매개 변수는 문법적으로 공통 주소 체계만 수용

![image-20230303184732283](../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230303184732283.png)

- Address Family

![image-20230303184750818](../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230303184750818.png)



##### DNS로부터 주소 얻기

- Domain Name System
  - 장점
    - 읽기, 쓰기, 기억의 편의성
      - 인터넷에서 호스트는 IP 주소로 구분이 가능
      - 숫자 형태보다, 계층화된 이름 주소가 더 좋은 사용 편의성을 제공
    - 고정된 주소 값 제공
      - IP 주소는 특성상 위치 이동 시 변경되나 네임 주소는 이를 클라이언트에 숨겨주어 다른 사람에게 항상 같은 주소를 제공한다
    - 부하 분배(load balancing)
      - 하나의 네임주소에 여러 개의 IP 주소 매핑이 가능하며 결과적으로 서로 다른 물리적인 서버가 클라이언트의 요청에 대응하게 할 수 있다
  - 특징
    - DNS가 TCP/IP 프로그래밍의 필수요소는 아님

- IPv4, IPv6 통합 네임 서비스 API
  - 기능 : 프로토콜 버전에 상관없이 네임 주소 -> IP 주소 해석을 해주는 함수
    - 호스트 주소(IP 혹은 도메인 네임)와 서비스(서비스 이름 혹은 port 번호)을 전달하면 위 정보에 연결 가능한 주소 정보(addrinfo) 리스트를 반환한다
    - 호스트 연결 시 도메인 네임, IPv4 주소, IPv6 주소를 모두 사용 가능
      - hostStr : 네임 주소 혹은 IP 주소
      - serviceStr : 서비스 이름 혹은 port 번호
      - hints : 반환을 원하는 주소 정보의 형태
        - IPv4 및 IPv6 선택, 프로토콜 종류 등의 선택이 가능
      - results : 반환되는 주소들의 결과 리스트

- addrinfo 구조체

![image-20230303185205299](../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230303185205299.png)

- Getaddrinfo 활용 예제

  ![image-20230303185226961](../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230303185226961.png)



##### 소켓 서비스

- 소켓 유형
  - SOCK_STREAM
    - 연결형 서비스를 지원
    - AF_INET에서는 TCP 프로토콜을 사용
  - SOCK_DGRM
    - 비연결형 서비스를 지원
    - AF_INET에서는 UDP 프로토콜을 사용
  - SOCK_RAW
    - IP 프로토콜을 직접 사용
  - SOCK_SEQPACKET
  - SOCK_RDM

- 소켓 함수
  - s = socket(int domain, int type, int protocol)
    - 매개 변수로 지정된 유형을 지원하는 소켓을 생성
    - 생성된 소켓을 가리키는 파일 디스크립터를 리턴
  - bind(int s, struct sockaddr *name, socklen_t *namelen)
    - s가 가리키는 소켓에 소켓 주소를 부여함
    - name : 소켓 주소
  - listen(int s, int backlog)
    - 소켓을 활성화 시킴
  - accept(int s, struct sockaddr *addr, socklen_t *addrlen)
    - 클라이언트/서버 환경에서 서버가 대기하는 역할을 함
    - 클라이언트의 connect() 함수와 만나면 소켓 연결을 설정함
  - send (int s, void *msg, size_t len, int flags)
    - 연결이 설정된 소켓에 데이터를 송신
    - 전송 데이터는 msg가 가리킴
  - recv (int s, void *buf, size_t len, int flags)
    - 연결이 설정된 소켓에서 데이터를 수신
    - 수신 데이터는 buf가 가리키는 공간에 저장됨

